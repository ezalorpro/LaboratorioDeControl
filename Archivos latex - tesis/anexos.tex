% --------------------------------------------------------------------
% Anexos -------------------------------------------------------------

% Código para agregar el informe académico en formato PDF ------------
% \includepdf[scale=0.7,pages=1,pagecommand={\AgregarAnexo{Informe académico}}, 
% addtotoc={1, chapter, 0,\bfseries\uppercase{Anexos}, pdf:informe}]{imagenes/informeAcademico}
% \includepdf[scale=0.7,pages=2, pagecommand={}]{imagenes/informeAcademico}
% --------------------------------------------------------------------
% Nota: Si se utiliza este código se deben comentar:
% \newpage
% \phantomsection
% \addcontentsline{toc}{chapter}{Anexos}
% --------------------------------------------------------------------

\newpage                                % Comentar si se incluye
\phantomsection                         % primero un pdf
\addcontentsline{toc}{chapter}{Anexos}  % Para evitar problemas TOC

% Para agregar anexos a la tesis
\AgregarAnexo{Codigo de los margenes de ganancia y fase}
    \begin{longlisting}
        \caption[Calculo de los margenes de ganancia y fase]{Función para el calculo de los margenes de ganancia y fase}
        \label{code:1}				
        \begin{minted}[escapeinside=||,
            mathescape=true,
            autogobble=true,
            fontsize=\footnotesize,
            obeytabs=true,
            tabsize=4,
            baselinestretch=1,
			breaklines]{python}
            def margenes_ganancias(self, system, mag, phase, omega):
                """
                [Funcion para obtener el margen de ganancia y el margen de fase]
                
                :param system: [Representación del sistema]
                :type system: [LTI]
                :param mag: [Magnitud de la respuesta en frecuencia]
                :type mag: [numpyArray]
                :param phase: [Fase de la respuesta en frecuencia]
                :type phase: [numpyArray]
                :param omega: [Frecuencias utilizadas para la respuesta en frecuencia]
                :type omega: [numpyArray]
                """

                gainDb = 20 * np.log10(mag)
                degPhase = phase * 180.0 / np.pi

                # Llevando la fase a : -360 < phase < 360, para +/- 360  phase -> 0
                comp_phase = np.copy(degPhase)
                degPhase = degPhase - (degPhase/360).astype(int) * 360

                # Para evitar la deteccion de cruces al llevar las fases al rango -360 < phase < 360
                crossHack1 = np.diff(1 * (degPhase > -183) != 0)
                crossHack2 = np.diff(1 * (degPhase > -177) != 0)
                crossHack = ~crossHack1 * ~crossHack2

                # Deteccion de cruce
                indPhase = np.diff(1 * (gainDb > 0) != 0)
                indGain = np.diff(1 * (degPhase > -180) != 0)
                indGain = indGain * crossHack

                # Calculo de la respuesta en frecuencia para omega = 0 rad/s
                zero_freq_response = ctrl.evalfr(system, 0j)
                omega = np.insert(omega, 0, 0)
                zeroPhase = np.angle(zero_freq_response)
                zeroMag = np.abs(zero_freq_response)
                if zeroPhase * 180.0 / np.pi >= 180:
                    zeroPhase = zeroPhase - 2 * np.pi
                gainDb = np.insert(gainDb, 0, 20 * np.log10(zeroMag))
                degPhase = np.insert(degPhase, 0, zeroPhase * 180.0 / np.pi)

                # Verificando "cruce" por -180 grados para omega = 0 rad/s
                if zeroPhase * 180.0 / np.pi == -180:
                    indGain = np.insert(indGain, 0, True)
                else:
                    indGain = np.insert(indGain, 0, False)

                # Verificando "cruce" por 0 dB para omega = 0 rad/s
                if 20 * np.log10(zeroMag) == 0:
                    indPhase = np.insert(indPhase, 0, True)
                else:
                    indPhase = np.insert(indPhase, 0, False)

                # Margen de ganancia
                if len(omega[:-1][indGain]) > 0:
                    newGainIndex = np.argmin(np.abs(gainDb[:-1][indGain]))
                    omegaGain = omega[:-1][indGain][newGainIndex]
                    GainMargin = -gainDb[:-1][indGain][newGainIndex]
                else:
                    omegaGain = np.nan
                    GainMargin = np.infty

                # Margen de Fase
                if len(omega[:-1][indPhase]) > 0:
                    newPhaIndex = min(range(len(degPhase[:-1][indPhase])),
                                    key=lambda i: abs(np.abs(degPhase[:-1][indPhase][i]) - 180))
                    omegaPhase = omega[:-1][indPhase][newPhaIndex]
                    PhaseMargin = 180 + degPhase[:-1][indPhase][newPhaIndex]
                else:
                    omegaPhase = np.nan
                    PhaseMargin = np.infty

                return GainMargin, PhaseMargin, omegaGain, omegaPhase
        \end{minted}
    \end{longlisting}

\AgregarAnexo{Ejemplo de un archivo CSV valido para la entonacion}
    \begin{longlisting}				
        \begin{minted}[escapeinside=||,
            mathescape=true,
            autogobble=true,
            fontsize=\footnotesize,
            obeytabs=true,
            tabsize=4,
            baselinestretch=1,
            breaklines]{text}
            $Date;$Time;VP2;EFC2;SP2
            02/22/12;01:21:00.000;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.070;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.140;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.210;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.280;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.350;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.420;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.490;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.560;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.630;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.700;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.770;0.6312256;5.233645;1.009346
            02/22/12;01:21:00.840;0.6313477;5.233645;1.009346
            02/22/12;01:21:00.910;0.6313477;5.233645;1.009346
            02/22/12;01:21:00.980;0.6313477;5.233645;1.009346
            02/22/12;01:21:01.050;0.6313477;5.233645;1.009346
            02/22/12;01:21:01.120;0.6313477;5.233645;1.009346
            02/22/12;01:21:01.190;0.6313477;5.233645;1.009346
            02/22/12;01:21:01.260;0.6313477;5.233645;1.009346
            02/22/12;01:21:01.330;0.6313477;5.233645;1.009346
            02/22/12;01:21:01.400;0.6313477;5.233645;1.009346
            02/22/12;01:21:01.470;0.6313477;5.233645;1.009346
            |$\qquad\vdots\qquad\qquad\qquad\vdots\quad\qquad\qquad\vdots\qquad\qquad\quad\vdots\qquad\qquad\vdots$|
            02/22/12;01:21:34.300;1.676147;6.654205;1.009346
            02/22/12;01:21:34.370;1.676147;6.654205;1.009346
            02/22/12;01:21:34.440;1.676147;6.654205;1.009346
            02/22/12;01:21:34.510;1.676147;6.654205;1.009346
            02/22/12;01:21:34.580;1.676147;6.654205;1.009346
            02/22/12;01:21:34.650;1.676147;6.654205;1.009346
            02/22/12;01:21:34.720;1.676147;6.654205;1.009346
            02/22/12;01:21:34.790;1.675903;6.654205;1.009346
            02/22/12;01:21:34.860;1.675903;6.654205;1.009346
            02/22/12;01:21:34.930;1.675903;6.654205;1.009346
            02/22/12;01:21:35.000;1.675903;6.654205;1.009346
        \end{minted}
    \end{longlisting}

    Esta data es valida porque posee tres o mas columnas, de las cuales, tres poseen un encabezado con las palabras claves necesarias (VP, EFC y TIME), se esta utilizando un separador valido (;), el formato de tiempo es correcto (hh:mm:ss) y la respuesta de la variable del proceso es ascendente.

 \AgregarAnexo{Codigo de transformacion equivalente entre funciones de membresia}
    \begin{longlisting}
        \caption[Transformación equivalente entre funciones de membresía]{Función para la transformación equivalente entre funciones de membresía}
        \label{code:1}				
        \begin{minted}[escapeinside=||,
            mathescape=true,
            autogobble=true,
            fontsize=\footnotesize,
            obeytabs=true,
            tabsize=4,
            baselinestretch=1,
			breaklines]{python}
            def update_definicionmf(self, old_mf, definicion, new_mf):
                """
                [Funcion para la transformacion equivalente entre funciones de membresia]
                
                :param old_mf: [Nombre de la antigua funcion de membresia]
                :type old_mf: [str]
                :param definicion: [Lista con los valroes correspondiente a la definicion de la antigua funcion de membresia]
                :type definicion: [list]
                :param new_mf: [Nombre de la nueva funcion de membresia]
                :type new_mf: [str]
                """
                
                if old_mf == 'trimf':
                    a, b, c = definicion

                    if new_mf == 'trimf':
                        na, nb, nc = a, b, c
                        return [na, nb, nc], '[a, b, c] con: a <= b <= c'

                    if new_mf == 'trapmf':
                        na, nd = a, c
                        nb = (a+b) / 2
                        nc = (b+c) / 2
                        return [na, nb, nc, nd], '[a, b, c, d] con: a <= b <= c <= d'

                    if new_mf == 'gaussmf':
                        mean = b
                        sigma = (abs(c) + abs(a)) / 8
                        return [sigma, mean], '[sigma, media]'

                    if new_mf == 'gauss2mf':
                        mean1 = (a+b) / 2
                        sigma1 = (abs(c) + abs(a)) / 16
                        mean2 = (b+c) / 2
                        sigma2 = (abs(c) + abs(a)) / 16
                        return [sigma1, mean1, sigma2, mean2], '[sigma1, media1, sigma2, media2] con: media1 <= media2'

                    if new_mf == 'smf' or new_mf == 'zmf':
                        na = (a+b) / 2
                        nb = (b+c) / 2
                        return [na, nb], '[a, b] siendo a el inicio del cambio \ny b el final del cambio'

                    if new_mf == 'sigmf':
                        nb = b
                        nc = 10 / (abs(c) + abs(a))
                        return [nc, nb], '[a, b] con:\n a como el ancho del sigmoide, puede ser negativo\n b el centro del sigmoide'

                    if new_mf == 'dsigmf':
                        nb1 = (a+b) / 2
                        nc1 = 20 / (abs(c) + abs(a))
                        nb2 = (b+c) / 2
                        nc2 = -20 / (abs(c) + abs(a))
                        return [nc1, nb1, nc2, nb2], '[a1, b1, a2, b2] con:\n b1, b2 como los centros de los sigmoides\n a1, a2 los anchos de los sigmoides, pueden ser negativos'

                    if new_mf == 'psigmf':
                        nb1 = (a+b) / 2
                        nc1 = 20 / (abs(c) + abs(a))
                        nb2 = (b+c) / 2
                        nc2 = -20 / (abs(c) + abs(a))
                        return [nc1, nb1, nc2, nb2], '[a1, b1, a2, b2] con:\n b1, b2 como los centros de los sigmoides\n a1, a2 los anchos de los sigmoides, pueden ser negativos'

                    if new_mf == 'pimf':
                        na, nd = a, c
                        nb = (a+b) / 2
                        nc = (b+c) / 2
                        return [na, nb, nc, nd], '[a, b, c, d] con:\na inicio de la subida y b su final por el lado izquierdo \nc inicio de la bajada y d su final por el lado derecho'

                    if new_mf == 'gbellmf':
                        na = abs(c) - abs(a)
                        nb = 1 / (a-b)
                        nc = b
                        return [na, nb, nc], '[a, b, c] con:\na como el ancho de la camapana\nb pendiente de la campana, puede ser negativa\nc centro de la camapana'

                if old_mf == 'trapmf':
                    a, b, c, d = definicion
                    na, nc = a, d
                    nb = (c+b) / 2
                    return [na, nb, nc], '[a, b, c] con: a <= b <= c'

                if old_mf == 'gaussmf':
                    b, a = definicion
                    na = a - b*4
                    nc = a + b*4
                    nb = a
                    return [na, nb, nc], '[a, b, c] con: a <= b <= c'

                if old_mf == 'gauss2mf':
                    b, a, d, c = definicion
                    na = a - b*4
                    nc = c + d*4
                    nb = (a+c) / 2
                    return [na, nb, nc], '[a, b, c] con: a <= b <= c'

                if old_mf == 'smf' or old_mf == 'zmf':
                    a, c = definicion
                    na = a - (abs(a) + abs(c)) / 4
                    nc = c + (abs(a) + abs(c)) / 4
                    nb = (a+c) / 2
                    return [na, nb, nc], '[a, b, c] con: a <= b <= c'

                if old_mf == 'sigmf':
                    c, b = definicion
                    na = b - abs(c) * 5
                    nb = b
                    nc = b + abs(c) * 5
                    return [na, nb, nc], '[a, b, c] con: a <= b <= c'

                if old_mf == 'dsigmf':
                    b, a, d, c = definicion
                    na = a - b*1.25
                    nb = (a+c) / 2
                    nc = c - d*1.25
                    return [na, nb, nc], '[a, b, c] con: a <= b <= c'

                if old_mf == 'psigmf':
                    b, a, d, c = definicion
                    na = a - b*1.25
                    nb = (a+c) / 2
                    nc = c - d*1.25
                    return [na, nb, nc], '[a, b, c] con: a <= b <= c'

                if old_mf == 'pimf':
                    a, b, c, d = definicion
                    na, nc = a, d
                    nb = (c+b) / 2
                    return [na, nb, nc], '[a, b, c] con: a <= b <= c'

                if old_mf == 'gbellmf':
                    a, b, c = definicion
                    na = c - abs(a / c)
                    nb = c
                    nc = c + abs(a / c)
                    return [na, nb, nc], '[a, b, c] con: a <= b <= c'
        \end{minted}
    \end{longlisting}

\AgregarAnexo{Formato interno para guardar controlador por medio de un archivo .JSON}
    \begin{longlisting}
        \caption[Formato para guardar controlador]{Formato para un controlador con una entrada, una salida y tres reglas. Las reglas son: una simple, una regla con premisa negada y una regla con salida ponderada en 0.25}
        \label{code:1}				
        \begin{minted}[escapeinside=||,
            mathescape=true,
            autogobble=true,
            fontsize=\footnotesize,
            obeytabs=true,
            tabsize=4,
            baselinestretch=1,
			breaklines]{python}
            [
                [
                    {
                        "nombre": "entrada1",
                        "numeroE": 3,
                        "etiquetas": [
                            {
                                "nombre": "etiqueta1",
                                "mf": "trimf",
                                "definicion": [
                                    -20.0,
                                    -10.0,
                                    0.0
                                ]
                            },
                            {
                                "nombre": "etiqueta2",
                                "mf": "trapmf",
                                "definicion": [
                                    -10.0,
                                    -5.0,
                                    5.0,
                                    10.0
                                ]
                            },
                            {
                                "nombre": "etiqueta3",
                                "mf": "gaussmf",
                                "definicion": [
                                    2.5,
                                    10.0
                                ]
                            }
                        ],
                        "rango": [
                            -10,
                            10
                        ]
                    }
                ],
                [
                    {
                        "nombre": "salida1",
                        "numeroE": 3,
                        "etiquetas": [
                            {
                                "nombre": "etiqueta1",
                                "mf": "gauss2mf",
                                "definicion": [
                                    1.25,
                                    -15.0,
                                    1.25,
                                    -5.0
                                ]
                            },
                            {
                                "nombre": "etiqueta2",
                                "mf": "dsigmf",
                                "definicion": [
                                    1.0,
                                    -5.0,
                                    1.0,
                                    5.0
                                ]
                            },
                            {
                                "nombre": "etiqueta3",
                                "mf": "pimf",
                                "definicion": [
                                    0.0,
                                    5.0,
                                    15.0,
                                    20.0
                                ]
                            }
                        ],
                        "rango": [
                            -10,
                            10
                        ],
                        "metodo": "centroid"
                    }
                ],
                [
                    [
                        [
                            [
                                "etiqueta1",
                                0,
                                false
                            ]
                        ],
                        [
                            [
                                "etiqueta1",
                                0,
                                1.0
                            ]
                        ],
                        true
                    ],
                    [
                        [
                            [
                                "etiqueta2",
                                0,
                                true
                            ]
                        ],
                        [
                            [
                                "etiqueta2",
                                0,
                                1.0
                            ]
                        ],
                        false
                    ],
                    [
                        [
                            [
                                "etiqueta3",
                                0,
                                false
                            ]
                        ],
                        [
                            [
                                "etiqueta3",
                                0,
                                0.24999999999999933
                            ]
                        ],
                        false
                    ]
                ]
            ]
        \end{minted}
    \end{longlisting}

\AgregarAnexo{Esquemas de control difuso}
    
    \vfill

    \begin{figure}[htb]
        \centering
        \includegraphics[width=\textwidth]{pdDifuso.pdf}
        \caption[Esquema de control implementado: PD difuso]{\textbf{Esquema de control implementado: PD difuso}. Fuente: Elaboración propia.} 
        \label{fig:pdDifuso}
    \end{figure}
    
    \vfill

    \begin{figure}[htb]
        \centering
        \includegraphics[width=\textwidth]{piDifuso.pdf}
        \caption[Esquema de control implementado: PI difuso]{\textbf{Esquema de control implementado: PI difuso}. Fuente: Elaboración propia.} 
        \label{fig:piDifuso}
    \end{figure}

    \vfill

    \begin{figure}[htb]
        \centering
        \includegraphics[width=\textwidth]{pidDifuso.pdf}
        \caption[Esquema de control implementado: PID difuso]{\textbf{Esquema de control implementado: PID difuso}. Fuente: Elaboración propia.} 
        \label{fig:pidDifuso}
    \end{figure}
    
    \vfill

    \pagebreak
    
    \vfill

    \begin{figure}[htb]
        \centering
        \includegraphics[width=\textwidth]{pipdDifuso.pdf}
        \caption[Esquema de control implementado: PD difuos mas PI difuso]{\textbf{Esquema de control implementado: PD difuos mas PI difuso}. Fuente: Elaboración propia.} 
        \label{fig:pipdDifuso}
    \end{figure}
    
    \vfill

    \begin{figure}[htb]
        \centering
        \includegraphics[width=\textwidth]{piplusDDifuso.pdf}
        \caption[Esquema de control implementado: PI difuso mas derivada]{\textbf{Esquema de control implementado: PI difuso mas derivada}. Fuente: Elaboración propia.} 
        \label{fig:piplusDDifuso}
    \end{figure}
    
    \vfill

    \begin{figure}[htb]
        \centering
        \includegraphics[width=\textwidth]{pdplusIDifuso.pdf}
        \caption[Esquema de control implementado: PD difuso mas integrador]{\textbf{Esquema de control implementado: PD difuso mas integrador}. Fuente: Elaboración propia.} 
        \label{fig:pdplusIDifuso}
    \end{figure}
    
    \vfill

    \pagebreak
    
    \vfill

    \begin{figure}[htb]
        \centering
        \includegraphics[width=\textwidth]{GainScheduler.pdf}
        \caption[Esquema de control implementado: Programador de ganancias]{\textbf{Esquema de control implementado: Programador de ganancias}. Fuente: Elaboración propia.} 
        \label{fig:GainScheduler}
    \end{figure}
    
    \vfill

    \begin{figure}[htb]
        \centering
        \includegraphics[width=\textwidth]{pidplusDifuso.pdf}
        \caption[Esquema de control implementado: PID clasico mas P difuso]{\textbf{Esquema de control implementado: PID clasico mas P difuso}. Fuente: Elaboración propia.} 
        \label{fig:pidplusDifuso}
    \end{figure}
    
    \vfill
